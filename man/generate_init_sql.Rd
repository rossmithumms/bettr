% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/query.R
\name{generate_init_sql}
\alias{generate_init_sql}
\title{Generate and Save ETL Table Initialization SQL}
\usage{
generate_init_sql(
  rows,
  table_name,
  connection_name,
  index_id_columns = TRUE,
  index_columns = c(),
  view_grants = c(),
  archive_clause = as.character(NA)
)
}
\arguments{
\item{rows}{Rows of data from an extract that are representative of the data
to be stored in the new table and presented in a new view.}

\item{table_name}{The name of the table.}

\item{connection_name}{The name of the database connection (schema user).}

\item{index_id_columns}{If TRUE, columns that end in \verb{_id} will automatically
have indexes created on them.  Defaults to TRUE.}

\item{index_columns}{A vector of column names to be indexed.  If parameter
\code{index_id_columns} = TRUE, this will supplement those columns.}

\item{view_grants}{The names of database roles to grant SELECT permissions.
Defaults to none.}

\item{archive_clause}{A logical clause as a SQL literal that identifies
stale rows in the table for the archive.  Defaults to NA, meaning no
archive table or archive management scripts will be created.}
}
\value{
Nothing.  This function is called for its side effect of writing an
initialization SQL file to the hard disk under the path given at the SQL_DIR
environment variable.  Defaults to none.
}
\description{
This is sugar to simplify the process of creating initialization SQL files.
It depends on the environmental variable SQL_DIR to be set.
This function will generate a SQL file that adds columns, indexes,
views, and grants.
The tables and views created are:
\itemize{
\item \verb{<TABLE_NAME>}: The live table
\item \verb{ARCH_<TABLE_NAME>}: The archive table (identical and empty)
\item \verb{V_<TABLE_NAME>}: View to the live table
\item \verb{V_ARCH_<TABLE_NAME>}: View to the archive table
\item \verb{V_ALL_<TABLE_NAME>}: View to a UNION of the live and archive tables
Indexes (which are created on all columsn ending in \verb{_id} and any
passed in the parameter \code{index_columns}) are created on the table.
If an \code{archive_clause} is passed, an additional archive table (with the
prefix \code{ARCH_}) will be created with the same indexes, as well as SQL
scripts used by the function \code{flush_to_archive()}.  These SQL files
will be named \verb{archive_get_live_<table_name>} (a SELECT statment to
get rows for the archive table) and \verb{archive_prune_live_<table_name>}
(a DELETE statement to delete the archived rows from the live table).
}
}
\details{
Note: The \code{archive_} and \code{prune_} files will be generated into the
task's local SQL dir.  To use these in a different task, you will need
to move these files yourself to that task's \verb{sql/<CONNECTION_NAME>}
directory. In general though, to avoid the possibility of multiple
tasks attempting to transact against the same table, it's best to use
\code{flush_to_archive()} in the same task that calls \code{generate_init_sql()}.
}
